# Shell vs Exec: чем отличаются и когда что выбирать

## Формы в Dockerfile
```dockerfile
ENTRYPOINT ["python", "app.py"]   # exec: PID 1 = python
ENTRYPOINT python app.py          # shell: PID 1 = /bin/sh -c

CMD ["python", "app.py"]          # exec
CMD python app.py                 # shell
```

## Коротко о разнице
- Exec-массив: нет шелла, сигналы доходят прямо до приложения, переменные окружения не подставляются в строку.
- Shell-форма: через `/bin/sh -c`, переменные подставляются, сигналы могут потеряться на PID 1 (shell).

## Крайне не рекомендуется смешивать формы в связке ENTRYPOINT + CMD
- ENTRYPOINT exec + CMD shell → в argv попадёт `/bin/sh -c ...`, параметры испортятся.
- ENTRYPOINT shell + CMD exec → CMD проигнорируется.
- Рабочий вариант: обе exec.
  ```dockerfile
  ENTRYPOINT ["python", "app.py"]
  CMD ["--verbose"]
  ```
  Получится: `python app.py --verbose`.
  Ещё проще, если всё в CMD:
  ```dockerfile
  CMD ["python", "app.py", "--verbose"]
  ```

## Компромисс через shell + exec
```dockerfile
CMD exec python app.py --verbose
```
Docker делает `/bin/sh -c "exec python app.py --verbose"`:
- PID 1 в итоге = python, сигналы ок
- Доступны подстановки `$VAR`, `&&`, `||`
- Минус: поведение зависит от конкретного shell базового образа

## Зачем вообще shell-форма
- Несколько команд: `CMD apt-get update && apt-get install -y curl && curl -s http://example.com`
- Подстановки `$(date)`, пайпы, условные конструкции
- Инициализационные скрипты с фоновыми процессами и финальным `exec app`
- Подстановка переменных в командную строку: `CMD echo $NAME`

Важно: в exec-форме переменные окружения видны приложению (через `os.environ`), но Docker не подставляет их в саму команду.

## Итог
- Exec — базовый вариант для сервисов и production.
- Shell/exec-компромисс — когда нужны возможности shell и при этом корректная обработка сигналов.